{"version":3,"file":"index.cjs","sources":["../src/hook/useI18n.ts","../src/I18n/index.tsx"],"sourcesContent":["import { useRouter } from \"next/router\"\nimport React from \"react\"\nimport dlv from \"dlv\"\n\nexport type I18nLocale = Exclude<string, \"count\" | \"params\">\n// @ts-expect-error circular reference\nexport type I18nSimpleParam = string | number | Record<string, I18nSimpleParam>\n\nexport type I18nParam =\n  | I18nSimpleParam\n  | JSX.Element\n  | ((arg: string, args: I18nParams) => string)\nexport type I18nSingleValue = string\nexport type I18nPluralValue = {\n  [n: number]: string\n  n?: string\n}\nexport type I18nParams = Record<string, I18nParam> & { count?: number }\n\nexport type TranslateFn = (\n  locales: Record<I18nLocale, I18nSingleValue | I18nPluralValue>,\n  args?: {\n    params?: I18nParams\n    count?: number\n  },\n) => string | JSX.Element | JSX.Element[]\n\nconst TAG_REGEXP = /<([a-z0-9_-]+)\\b[^>]*>(.*?)<\\/\\1>/gi\nconst STR_REGEXP = /{{([a-z0-9._-]+)\\s*(.*?)}}/gi\nconst LITERAL_REGEXP = /^\"(.*)\"$/i\n\nfunction useI18n() {\n  const { locale, locales, defaultLocale } = useRouter()\n\n  const getBest = (\n    locales: Record<I18nLocale, I18nSingleValue | I18nPluralValue>,\n  ) => {\n    if (locale && locale in locales) {\n      return locales[locale]\n    }\n\n    if (defaultLocale && defaultLocale in locales) {\n      return locales[defaultLocale]\n    }\n\n    throw new Error(`I18n no string for ${defaultLocale}`)\n  }\n\n  const getValue = (\n    locales: Record<I18nLocale, I18nSingleValue | I18nPluralValue>,\n    count?: number,\n  ) => {\n    const value = getBest(locales)\n    return typeof value === \"object\"\n      ? count in value\n        ? value[count]\n        : value[\"n\"]\n      : value\n  }\n\n  const t: TranslateFn = (locales, args) => {\n    let value = getValue(locales, args?.count)\n\n    if (args?.params) {\n      value = value\n        .toString()\n        .replace(STR_REGEXP, function (_, variable: string, arg: string) {\n          const substitute = dlv(args.params, variable)\n          return typeof substitute === \"function\"\n            ? substitute(\n                LITERAL_REGEXP.test(arg)\n                  ? arg.substring(1, arg.length - 1)\n                  : dlv(args.params, arg),\n              )\n            : substitute.toString()\n        })\n\n      if (TAG_REGEXP.test(value)) {\n        return value.split(TAG_REGEXP).map((part, i, array) => {\n          // must match 2nd and 3rd param on a group of four\n          // see tests for example\n          if (i % 3 !== 1) return part as unknown as JSX.Element\n\n          const element = dlv(args.params, part)\n          if (!React.isValidElement(element)) {\n            throw new Error(`I18n non JSX in <${part}>.`)\n          }\n          // empty the next one, which is a child element\n          const child = array[i + 1]\n          array[i + 1] = \"\"\n\n          return React.cloneElement(element, {\n            // @ts-expect-error JSX props type is unknown\n            ...element.props,\n            key: i,\n            children: child,\n          }) as JSX.Element\n        })\n      }\n    }\n\n    return value\n  }\n\n  return {\n    t,\n    locale,\n    locales,\n    defaultLocale,\n  }\n}\n\nexport default useI18n\n","import useI18n, {\n  I18nLocale,\n  I18nParams,\n  I18nPluralValue,\n  I18nSingleValue,\n} from \"../hook/useI18n\"\nimport React, { FC } from \"react\"\n\ntype I18nProps =\n  | Record<I18nLocale, I18nSingleValue | I18nPluralValue>\n  | {\n      count?: number\n      params?: I18nParams\n    }\n\nconst I18n: FC<I18nProps> = (props) => {\n  const { params, count, ...texts } = props\n  const { t } = useI18n()\n  return (\n    <React.Fragment>\n      {t(texts as Record<I18nLocale, I18nSingleValue | I18nPluralValue>, {\n        params: params as I18nParams,\n        count: count as number,\n      })}\n    </React.Fragment>\n  )\n}\n\nexport default I18n\n"],"names":["TAG_REGEXP","STR_REGEXP","LITERAL_REGEXP","useI18n","useRouter","locale","defaultLocale","t","locales","args","value","count","Error","getBest","getValue","params","toString","replace","_","variable","arg","substitute","dlv","test","substring","length","split","map","part","i","array","element","React","isValidElement","child","cloneElement","props","key","children","texts","_jsx","Fragment"],"mappings":"oaA2BA,IAAMA,EAAa,sCACbC,EAAa,+BACbC,EAAiB,YAEvB,SAASC,IACP,MAA2CC,cAAnCC,IAAAA,OAAiBC,IAAAA,cAwEzB,MAAO,CACLC,EA7CqB,SAACC,EAASC,GAC/B,IAAIC,EAbW,SACfF,EACAG,GAEA,IAAMD,EAlBQ,SACdF,GAEA,GAAIH,GAAUA,KAAUG,EACtB,OAAOA,EAAQH,GAGjB,GAAIC,GAAiBA,KAAiBE,EACpC,OAAOA,EAAQF,GAGjB,UAAUM,4BAA4BN,GAOxBO,CAAQL,GACtB,MAAwB,iBAAVE,EACVC,KAASD,EACPA,EAAMC,GACND,EAAK,EACPA,EAIQI,CAASN,QAASC,SAAAA,EAAME,OAEpC,aAAIF,GAAAA,EAAMM,SACRL,EAAQA,EACLM,WACAC,QAAQhB,EAAY,SAAUiB,EAAGC,EAAkBC,GAClD,IAAMC,EAAaC,UAAIb,EAAKM,OAAQI,GACpC,MAA6B,mBAAfE,EACVA,EACEnB,EAAeqB,KAAKH,GAChBA,EAAII,UAAU,EAAGJ,EAAIK,OAAS,GAC9BH,UAAIb,EAAKM,OAAQK,IAEvBC,EAAWL,aAGfhB,EAAWuB,KAAKb,IACXA,EAAMgB,MAAM1B,GAAY2B,IAAI,SAACC,EAAMC,EAAGC,GAG3C,GAAID,EAAI,GAAM,EAAG,OAAOD,EAExB,IAAMG,EAAUT,UAAIb,EAAKM,OAAQa,GACjC,IAAKI,UAAMC,eAAeF,GACxB,UAAUnB,0BAA0BgB,QAGtC,IAAMM,EAAQJ,EAAMD,EAAI,GAGxB,OAFAC,EAAMD,EAAI,GAAK,GAERG,UAAMG,aAAaJ,OAErBA,EAAQK,OACXC,IAAKR,EACLS,SAAUJ,OAMXxB,GAKPL,OAAAA,EACAG,UA3EcA,QA4EdF,cAAAA,yCC7FwB,SAAC8B,GAC3B,IAAQrB,EAA4BqB,EAA5BrB,OAAQJ,EAAoByB,EAApBzB,MAAU4B,qIAAUH,OACtBjC,IACd,OACEqC,MAACR,UAAMS,oBACJlC,IAHGA,GAGDgC,EAAgE,CACjExB,OAAQA,EACRJ,MAAOA"}